Now big change incoming.

Premise: as you might have understood the idea here is to build the model once to run it one or more times, in order to extract the best couple of phi (measurement matrix) and dict (dictionary). Once extracted we want to rebuild the class feeding as argument such extracted model.

Crucial points:
1. it's difficult when rebuilding to automatically understand if the phi fed is a kronecker version or not, given this we will work in the following way; if the recovery_only flag is on, it will be mandatory to feed as argument a unique object (python dictionary or structure) that contains the following:
phi, dict, a flag that can be toggled that tells that it is or it isn't a kronecker version, if such flag says it is kronecker then we must also have in the model we give as argument a original_phi matrix (the non kronecker version). An object not compliant with the correct stucture should immediately raise error.
By doing this the idea is that we give the model and he one of these happen: the kronecker version flag is off, so the phi matrix is a non kronecker one, it can immediately launch compress_test_set with such phi (internal call in the constructor); after this from outside we can call recovery_signal, to recover and plot to plot.
In the other case the flag is on, so immediately we need to do the compression with original phi to obtain Y, then we need to obtain Y in version kronecker: we basically have to update BLOCK_LEN with the number of rows of the phi (not original_phi) do the reshaping that happens inside the kronecker_activate. We are now ready with recovery_signal (to be called externally from script) to rebuild using phi (which is kronecer version), dict (also kron), Y that we just made kronecker version.
When we build with recovery_only we still need to be imposssible to do compress_test_set because it happens in the instantiation, also generate_dictionary shouldn't be possibile (I think we already did this two, but check again). Also kronecker activate should be possible only if the object didn;t contain already kron, so check kron flag in argument object. also divide_signal shouldn't be possible, i think we already took care but check. recovery signal and plot should work fine
Note that inserting BLOCK_LEN, CR=4, matrix_type='gaussian', when instantiating feeding the model, such parameters are useless, so first of all we should put a default for BLOCK_LEN (16), also we should perform a check if when launched in the recovery_only mode, if the BLOCK_LEN doesn't coincide with the len of phi in non_kron case, original_phi in kron case then we should raise error stating that that three parameters are not to be used when recovery only is on

2. In order for this to be possible it is necessary that when we run the first time to output the model, the model it's created in consistent way with what we said, so basically: if we never kronecker_activate then at the end we must be able to extract an object that contains phi, dict, kron flag to false, original_phi=None. If we did kronecker: phi, dict, kron flag to true, original_phi.



Too much of a mess, let's divide in two classes...

The firs class will be as the orignal one was: no recovery_only mode, just plain and simple old style instantiation where we give signal, BLOCK_LEN=16, CR=4, matrix_type='gaussian' as arguments.  We perfom check and then only "normal mode", similarly to what follwos, correct accordingly:

def __init__(self, signal, BLOCK_LEN=16, CR=4, matrix_type='gaussian', model=None, recovery_only=False):
        """
        Constructor for the compressedSensing class.

        Parameters:
        -----------
        signal : numpy.ndarray
            The input signal, must be a valid array of real numbers.
        BLOCK_LEN : int
            The number of rows in the measurement matrix Phi. Default is 16.
        CR : int, optional (default=4)
            Compression ratio (controls the number of rows in Phi). Must be a positive integer and BLOCK_LEN / CR > 1.
        matrix_type : str, optional (default='gaussian')
            Type of the matrix to generate ('gaussian', 'DBBD', etc.).
        model : dict, optional
            A model containing 'phi', 'dict', 'is_kron', and optionally 'original_phi' if Kronecker compression was used.
        recovery_only : bool, optional (default=False)
            If True, skips training and focuses only on signal recovery using the pre-provided model.
        """
        
        # Check if signal is valid
        if signal is None:
            raise ValueError("A signal must be provided.")
        
        # Ensure signal is a vector-like structure (array or list of real numbers)
        if not (isinstance(signal, (list, np.ndarray)) and np.issubdtype(np.array(signal).dtype, np.number)):
            raise ValueError("The signal must be a valid array or list of numerical values.")
        
        self.signal = np.array(signal)  # Convert to numpy array if it isn't already
        self.recovery_only = recovery_only

            # In normal mode
            self.BLOCK_LEN = BLOCK_LEN
            self.CR = CR
            self.COMP_LEN = BLOCK_LEN // CR  # Compression length (number of rows in Phi)

            # Generate measurement matrix Phi based on the specified type
            if matrix_type == 'DBBD':
                self.Phi = generate_DBBD_matrix(self.COMP_LEN, self.BLOCK_LEN)
            else:
                self.Phi = generate_random_matrix(self.COMP_LEN, self.BLOCK_LEN, matrix_type=matrix_type)
        
        # Initialize other attributes
        self.training_set = None
        self.training_matrix = None
        self.reconstructed_signal = None
        self.Y = None  # Compressed test signal
        self.theta = None
        self.theta_pinv = None
        self.coeff_matrix = None  # Coefficients from MOD or K-SVD algorithm

Afetr instantiation we have that can be called: divide_signal,  compress_test_set, kronecker_activate, generate_dictionary, recover_signal, and the final plotter, also we have all the function to recover attributes and the function to recover the model.

We will later generate a class to use the model


Class inheritance build

We previously spoke of inheritance, composition, and abstract base classes. For sure we want inheritance, probably with abstract classes.
I will now explain myself.

we should have base class, then two subclasses: normal and recovery only
Normal should perform what it does now, but some methods will be derived from base class, some overwritten, some added.
Same goes with the one we have to create: the recovery only one.

divide_signal should exist only in normal version.

compress_test_set exists in both it should be inherited from base class cause they can use it the same.

Y_kron should exist the same for both, inherited from base class

kronecker_activate should exist in both,b ut it;s different! The version in normal calss should be:
def kronecker_activate(self, KRON_FACT):
        """
        Activates Kronecker compression, adjusting BLOCK_LEN and reprocessing Phi and Y accordingly.
        """
        if hasattr(self, 'is_kron') and self.is_kron:
            raise ValueError("Kronecker compression has already been activated. Cannot activate again.")

        if self.Y is None:
            raise ValueError("Y has not been computed. Please compress the signal before activating the kronecker method.")
        
        self.KRON_FACT = KRON_FACT
        self.BLOCK_LEN = self.BLOCK_LEN * self.KRON_FACT

        # Compute Kronecker product for Phi
        self.Phi = np.kron(np.eye(self.KRON_FACT), self.Phi)

        # Reprocess the training set if it exists
        if self.training_set is not None:
            training_size = len(self.training_set)
            num_cols = training_size // self.BLOCK_LEN
            if num_cols < self.BLOCK_LEN:
                warnings.warn("The number of samples (columns) in the training matrix is shorter than "
                            "the number of rows, which can cause issues with dictionary learning.")
            
            self.training_matrix = self.training_set[:num_cols * self.BLOCK_LEN].reshape(self.BLOCK_LEN, num_cols, order='F')
        
        self.Y_kron()

        # Set the is_kron flag to True
        self.is_kron = True

While the version in recovery only shoudn't have the part where: # Reprocess the training set if it exists. Also we have to expan with kronecker product not only phi with self.Phi = np.kron(np.eye(self.KRON_FACT), self.Phi), but the same thing has to be made to the dictionary.

geenrate_dictionary should be normal class only

Constructor: each of the two subclasses should have it's own, they work very differently.
The one in normal class it's already correct.

The one in the recovery only should perform this: accept as argument two things, a signal and the dictionary "model" that comes as output from the other subclass. The signal is immediately put in self.test_set 
After that it checks if is_kron is true or false, if it is false then phi inside the class gets set to phi in the model, dict to dict in the model, original_phi to original_phi, then call compress_test_set and here it stops (maybe only Initialize all parameters including is_kron to false).
If is_kron flag in model is true: in the phi inside the class gets set to phi in the model, dict to dict in the model, original_phi to original_phi, compress_test_set is called, then Y_kron is called and the flag self.is_kron is set to true.

You have everything you need to produce the whole thing.

Please put every piece in a different code block